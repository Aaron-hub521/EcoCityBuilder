// Define the full game rules markdown string (accessible globally)
const fullGameRulesMarkdown = `# EcoCity Builder - Game Rules\n\n## Gameplay\n\nEcoCity Builder is a city-building simulation game where the player aims to build a thriving and sustainable city.\n\n**Core Mechanics:**\n\n1.  **Building:** Players select buildings from a menu and place them on the grid-based map.\n2.  **Resource Management:** Players manage:\n    *   **Money:** Used to build structures. Generated by certain buildings (Factories, Shops, etc.) and reduced by building costs. Running out of money leads to game over.\n    *   **Pollution:** Generated by certain buildings (Factories, Power Plants, etc.). Some structures (Wastewater Plants) reduce pollution over time. High pollution leads to game over.\n    *   **Happiness:** Affected positively or negatively by different buildings. Some buildings (Schools, Libraries) provide happiness bonuses to nearby Houses within a certain radius. Low happiness can trigger protests.\n    *   **Population:** Increased primarily by building Houses. Required for certain win conditions. High pollution causes population to drop to zero.\n3.  **Building Limits:** Most buildings have a maximum number that can be built.\n4.  **Building Placement:** Buildings cost money to place. They cannot overlap with existing buildings.\n5.  **Building Removal:** Existing buildings can be removed (by right-clicking), refunding 50% of their original cost and reversing their effects on pollution, happiness, and population.\n6.  **Building Movement:** Existing buildings can be moved (by left-clicking and dragging). Moving temporarily removes the building's effects. The building must be placed in a valid, unoccupied location.\n7.  **Income:** Some buildings (Factories, Shops, Airport, Science Lab, Train Station) generate income periodically.\n8.  **Events:** Random events occur periodically (every 30 seconds):\n    *   **Disasters (20% chance):**\n        *   Earthquake: Randomly destroys one building (50% chance of being saved if within range of a Fire Station).\n        *   Flood: Increases pollution by 10.\n    *   **Protests:** Can occur if happiness is 30 or lower. Chance is reduced by Police Stations. Protests temporarily stop all income generation.\n9.  **Area Effects:** Some buildings (Schools, Libraries) provide happiness bonuses to Houses within their effect radius. Fire Stations and Police Stations provide protective effects within their radius.\n\n**Starting State:**\n\n*   Money: 10000\n*   Pollution: 0\n*   Happiness: 0\n*   Population: 0\n\n## Win Conditions\n\nAchieve any *one* of the following goals:\n\n1.  **Zero Carbon City:**\n    *   Pollution = 0\n    *   Money >= 5000\n    *   At least one building placed\n2.  **Population Boom:**\n    *   Happiness >= 80\n    *   Population >= 100,000\n3.  **Economic Powerhouse:**\n    *   Money >= 30,000\n\nUpon achieving a win condition, the game pauses and a victory message is displayed.\n\n## Loss Conditions\n\nGame over occurs if *either* of the following happens:\n\n1.  **Bankruptcy:** Money <= 0\n2.  **Pollution Crisis:** Pollution >= 100 (causes population to drop to 0)\n\nUpon reaching a loss condition, a game over message is displayed, and the game resets to the initial state.\n\n## Building Stats\n\n| Building        | Cost   | Pollution | Happiness | Population | Income | Income Interval (ms) | Effect Radius (grid units) | Max Count | Special Effects / Notes                                                                                                |\n| :-------------- | :----- | :-------- | :-------- | :--------- | :----- | :------------------- | :------------------------- | :-------- | :--------------------------------------------------------------------------------------------------------------------- |\n| **House**       | 750    | 1         | 1         | 80         | 0      | -                    | 0                          | None      | Primary source of population. Receives happiness bonus from Schools & Libraries.                                       |\n| **Factory**     | 1500   | 8         | -5        | 0          | 150    | 12000                | 0                          | 10        | Generates income. Major source of pollution.                                                                           |\n| **Hospital**    | 2500   | 1         | 3         | 0          | 0      | -                    | 0                          | 5         | Special: \`reduce_disease\` (Effect not fully detailed in code)                                                            |\n| **Shop**        | 1200   | 2         | 0         | 0          | 40     | 6000                 | 0                          | 15        | Generates income.                                                                                                      |\n| **School**      | 3000   | 2         | 2         | 0          | 0      | -                    | 4                          | 5         | Special: \`happiness_bonus_large\`. Provides +2 Happiness bonus to Houses within radius.                                   |\n| **Wastewater**  | 2200   | 1         | -2        | 0          | 0      | -                    | 0                          | 3         | Special: \`periodic_pollution_reduction\`. Reduces total pollution by 4 every 6000ms.                                    |\n| **Airport**     | 10000  | 15        | -3        | 0          | 500    | 20000                | 0                          | 1         | Generates high income. High pollution.                                                                                 |\n| **Court**       | 4000   | 1         | 1         | 0          | 0      | -                    | 0                          | 3         |                                                                                                                        |\n| **Fire Station**| 2000   | 2         | 1         | 0          | 0      | -                    | 5                          | 5         | Special: \`reduce_disaster_impact\`. 50% chance to prevent building destruction from earthquakes within radius.             |\n| **Library**     | 1800   | 1         | 2         | 0          | 0      | -                    | 2                          | 8         | Special: \`happiness_bonus_small\`. Provides +2 Happiness bonus to Houses within radius.                                   |\n| **Police Station**| 2200   | 1         | 1         | 0          | 0      | -                    | 5                          | 5         | Special: \`reduce_protest_chance\`. Reduces the chance of protests occurring by 75% (city-wide effect, radius unused?). |\n| **Power Plant** | 6000   | 12        | -4        | 0          | 0      | -                    | 0                          | 3         | High pollution source.                                                                                                 |\n| **Science Lab** | 7000   | 5         | 3         | 0          | 100    | 15000                | 0                          | 2         | Generates income.                                                                                                      |\n| **Train Station**| 8000   | 8         | -2        | 0          | 300    | 18000                | 0                          | 2         | Generates income. High pollution.                                                                                      |\n| **Waste Dump**  | 2500   | 6         | -3        | 0          | 0      | -                    | 0                          | 4         | Source of pollution.                                                                                                   |\n| **Water Supply**| 1500   | 1         | 1         | 0          | 0      | -                    | 0                          | 5         |                                                                                                                        |\n\n**Notes:**\n\n*   \`Effect Radius\` is measured in grid units (each grid square is 32x32 pixels).\n*   \`Income Interval\` is the time in milliseconds between income payouts.\n*   Some \`special\` effects mentioned in the code comments (like \`reduce_disease\`) don't have explicit implementation details visible in the analyzed functions.\n*   The Police Station's effect seems to apply city-wide based on the \`checkProtestEvent\` logic, despite having an effect radius defined.\n`;

// Define the rule summary string (accessible globally)
const ruleSummary = `<strong>胜利条件:</strong><br>- 零碳城市: 污染 = 0, 资金 >= 5000, 建筑 > 0<br>- 人口繁荣: 满意度 >= 80, 人口 >= 100,000<br>- 经济霸主: 资金 >= 30,000<br><br><strong>失败条件:</strong><br>- 破产: 资金 <= 0<br>- 污染危机: 污染 >= 100 (人口变为 0)`;

console.log('game.js loaded at the very top'); // 确认文件加载
// Phaser配置和全局变量
const config = {
    type: Phaser.CANVAS, // Force Canvas renderer for debugging
    parent: 'game-container',
    width: 1800,
    height: 1500,
    scene: { preload, create, update },
    pixelArt: true,
    antialias: false,
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH }
};

let currentMoney = 10000;
let currentPollution = 0;
let currentHappiness = 0; // Initial happiness
let currentPopulation = 0; // Initial population
const GRID_SIZE = 32;

// 建筑属性定义
// 建筑属性定义 (难度增加)
const buildingData = {
    house: { cost: 750, pollution: 1, happiness: 1, population: 80, income: 0, effectRadius: 0, special: null, imageKey: 'house', displayName: 'House', maxCount: null }, // 成本增加, 轻微污染, 满意度降低, 人口减少, 无数量上限
    factory: { cost: 1500, pollution: 8, happiness: -5, population: 0, income: 150, incomeInterval: 12000, effectRadius: 0, special: null, imageKey: 'factory', displayName: 'Factory', maxCount: 10 }, // 成本增加, 污染增加, 满意度降低, 收入减少, 间隔增加, 上限10
    hospital: { cost: 2500, pollution: 1, happiness: 3, population: 0, income: 0, effectRadius: 0, special: 'reduce_disease', imageKey: 'hospital', displayName: 'Hospital', maxCount: 5 }, // 成本大幅增加, 轻微污染, 满意度降低, 上限5
    shop: { cost: 1200, pollution: 2, happiness: 0, population: 0, income: 40, incomeInterval: 6000, effectRadius: 0, special: null, imageKey: 'shop', displayName: 'Shop', maxCount: 15 }, // 成本增加, 污染增加, 满意度降低, 收入减少, 间隔增加, 上限15
    // road: { cost: 100, pollution: 0, happiness: 0, population: 0, income: 0, effectRadius: 0, special: null, imageKey: 'road' }, // Removed
    // tree: { cost: 50, pollution: -2, happiness: 1, population: 0, income: 0, effectRadius: 1 * GRID_SIZE, special: 'happiness_bonus_small', imageKey: 'tree' }, // Removed
    school: { cost: 3000, pollution: 2, happiness: 2, population: 0, income: 0, effectRadius: 4 * GRID_SIZE, special: 'happiness_bonus_large', imageKey: 'school', displayName: 'School', maxCount: 5 }, // 成本大幅增加, 污染增加, 满意度降低, 效果半径减小, 上限5
    // park: { cost: 800, pollution: -3, happiness: 2, population: 0, income: 0, effectRadius: 2 * GRID_SIZE, special: 'happiness_bonus_medium', imageKey: 'park', displayName: '公园', maxCount: 10 } // Removed Park
    wastewater: { cost: 2200, pollution: 1, happiness: -2, population: 0, income: 0, effectRadius: 0, special: 'periodic_pollution_reduction', pollutionReduction: 4, pollutionInterval: 6000, imageKey: 'wastewater', displayName: 'Wastewater', maxCount: 3 }, // 新增：污水处理厂
    // 注意：重复的 house 和 factory 定义已被合并和移除

    // --- New Buildings with Default Values ---
    airport: { cost: 10000, pollution: 15, happiness: -3, population: 0, income: 500, incomeInterval: 20000, effectRadius: 0, special: null, imageKey: 'airport', displayName: 'Airport', maxCount: 1 },
    court: { cost: 4000, pollution: 1, happiness: 1, population: 0, income: 0, effectRadius: 0, special: null, imageKey: 'court', displayName: 'Court', maxCount: 3 },
    fire: { cost: 2000, pollution: 2, happiness: 1, population: 0, income: 0, effectRadius: 5 * GRID_SIZE, special: 'reduce_disaster_impact', imageKey: 'fire', displayName: 'Fire Station', maxCount: 5 },
    library: { cost: 1800, pollution: 1, happiness: 2, population: 0, income: 0, effectRadius: 2 * GRID_SIZE, special: 'happiness_bonus_small', imageKey: 'library', displayName: 'Library', maxCount: 8 },
    police: { cost: 2200, pollution: 1, happiness: 1, population: 0, income: 0, effectRadius: 5 * GRID_SIZE, special: 'reduce_protest_chance', imageKey: 'police', displayName: 'Police Station', maxCount: 5 },
    power: { cost: 6000, pollution: 12, happiness: -4, population: 0, income: 0, effectRadius: 0, special: null, imageKey: 'power', displayName: 'Power Plant', maxCount: 3 },
    science: { cost: 7000, pollution: 5, happiness: 3, population: 0, income: 100, incomeInterval: 15000, effectRadius: 0, special: null, imageKey: 'science', displayName: 'Science Lab', maxCount: 2 },
    train: { cost: 8000, pollution: 8, happiness: -2, population: 0, income: 300, incomeInterval: 18000, effectRadius: 0, special: null, imageKey: 'train', displayName: 'Train Station', maxCount: 2 },
    waste: { cost: 2500, pollution: 6, happiness: -3, population: 0, income: 0, effectRadius: 0, special: null, imageKey: 'waste', displayName: 'Waste Dump', maxCount: 4 },
    watersupply: { cost: 1500, pollution: 1, happiness: 1, population: 0, income: 0, effectRadius: 0, special: null, imageKey: 'watersupply', displayName: 'Water Supply', maxCount: 5 },
};

let placedBuildings = []; // 存储已放置的建筑对象及其位置
let factoryIncomeTimer; // 工厂收入计时器
let pollutionReductionTimer = null; // 污水处理计时器 (新增)
let gameScene; // 保存场景引用
let eventTimer; // 动态事件计时器

// 新增：放置模式相关变量
let isPlacingBuilding = false; // 旧的放置模式标志，可能需要清理
let selectedBuildingType = null; // 旧的放置模式标志
let placementPreview = null; // 旧的放置预览

// --- 拖放状态变量 (全局) ---
let isDraggingBuilding = false;
let draggedBuildingType = null;
let dragPreview = null;

// --- 移动状态变量 (全局) ---
let isMovingBuilding = false;
let movingBuildingObject = null;
let originalMovePos = { x: null, y: null };

const initialScale = 0.1; // Increased scale for menu items
const PLACED_BUILDING_SCALE = 0.09375; // Use the larger scale for placed buildings too

// 预加载资源
function preload() {
    console.log('Preload function started'); // 添加日志
    // Paths should be relative to index.html
    this.load.image('house', 'src/assets/pixel/house.png');
    this.load.image('factory', 'src/assets/pixel/factory.png');
    this.load.image('shop', 'src/assets/pixel/shop.png');
    this.load.image('school', 'src/assets/pixel/school.png');
    this.load.image('hospital', 'src/assets/pixel/hospital.png');
    this.load.image('wastewater', 'src/assets/pixel/wastewater_plant.png'); // Use new key, load old filename
    // Removed old assets
    // this.load.image('road', 'src/assets/pixel/road.png');
    // this.load.image('tree', 'src/assets/pixel/tree.png');
    // this.load.image('park', 'src/assets/pixel/park.png');

    // --- Load New Building Images ---
    this.load.image('airport', 'src/assets/pixel/airport.png');
    this.load.image('court', 'src/assets/pixel/court.png');
    this.load.image('fire', 'src/assets/pixel/fire.png');
    this.load.image('library', 'src/assets/pixel/library.png');
    this.load.image('police', 'src/assets/pixel/police.png');
    this.load.image('power', 'src/assets/pixel/power.png');
    this.load.image('science', 'src/assets/pixel/science.png');
    this.load.image('train', 'src/assets/pixel/train.png');
    this.load.image('waste', 'src/assets/pixel/waste.png');
    this.load.image('watersupply', 'src/assets/pixel/watersupply.png');

    // Log when loading is complete
    this.load.on('complete', () => {
        console.log('Asset loading complete.');
    });
    this.load.on('loaderror', (file) => {
        console.error('Error loading asset:', file.key);
    });
}

// 场景初始化
function create() {
    gameScene = this; // 保存场景引用
    console.log('Create function started'); // 添加日志
    // 背景和网格 (Adjusted for new config size)
    this.add.rectangle(config.width / 2, config.height / 2, config.width, config.height, 0x2d2d2d).setDepth(-1); 
    this.add.grid(config.width / 2, config.height / 2, config.width * 2, config.height * 2, GRID_SIZE, GRID_SIZE, 0x3a3a3a, 0.3).setDepth(0); // Grid already covers larger area

    // --- REMOVED: Phaser Menu Drawing CODE --- 
    // The menu is now handled by HTML/CSS and generated in createHtmlMenu()

    // 启动工厂收入 (如果已有工厂)
    startFactoryIncome(this);

    // 启动动态事件计时器
    startEventTimer(this);

    // 启动污染减少计时器 (如果已有处理厂)
    startPollutionReduction(this);

    // 添加摄像机控制 (Adjusted bounds for new config size)
    this.cameras.main.setBounds(0, 0, config.width * 2, config.height * 2); // Extend camera bounds
    /* // Removed wheel zoom functionality
    this.input.on('wheel', (pointer, gameObjects, deltaX, deltaY, deltaZ) => {
        let newZoom = this.cameras.main.zoom - deltaY * 0.001;
        // 限制缩放范围
        newZoom = Phaser.Math.Clamp(newZoom, 0.5, 2);
        this.cameras.main.zoomTo(newZoom, 300); // 平滑缩放
    });
    */

    // 平移逻辑
    let isPanning = false;
    let startPanX = 0;
    let startPanY = 0;
    this.input.keyboard.on('keydown-SPACE', () => {
        isPanning = true;
        // 可以在这里改变鼠标指针样式
    });
    this.input.keyboard.on('keyup-SPACE', () => {
        isPanning = false;
        // 恢复鼠标指针样式
    });

    // Signal that the game scene is ready
    console.log('Dispatching game-ready event');
    document.dispatchEvent(new Event('game-ready'));

    // --- Call HTML Menu Creation AFTER scene is ready ---
    // Note: Ensure this runs after gameScene is assigned and buildingData is available
    // We'll add the actual call later, perhaps tied to DOMContentLoaded or game-ready

    // Removed redundant pointerdown listener for panning initiation

    // Removed incomplete panning pointermove listener

    // Expose getGameState globally AFTER it's defined
    window.getGameState = getGameState;
    console.log('getGameState function exposed to window.');

    // Initial UI update
    updateStats(); // Call this once at the start

    // 添加ESC键取消放置
    this.input.keyboard.on('keydown-ESC', () => {
        if (isDraggingBuilding) {
            cancelPlacement(); // Cancel dragging from menu
        } else if (isMovingBuilding) {
            cancelMovingBuilding(); // Cancel moving existing building
        }
    });
}

// --- 拖放和放置辅助函数 ---

// 开始拖动建筑 (由 dragstart 调用)
function startDraggingBuilding(type, pointerX, pointerY) { // 接收类型和初始指针位置
    console.log(`Attempting to start drag for ${type} at (${pointerX}, ${pointerY})`);
    if (!buildingData[type]) {
        console.error(`Building data not found for type: ${type}`);
        return;
    }
    // draggedBuildingType = type; // Set type later
    // console.log(`Successfully started drag for: ${draggedBuildingType}`);

    // 创建拖动预览图像
    if (dragPreview) dragPreview.destroy(); // 清除旧预览
    const worldPoint = gameScene.cameras.main.getWorldPoint(pointerX, pointerY);
    dragPreview = gameScene.add.image(worldPoint.x, worldPoint.y, buildingData[type].imageKey)
        .setScale(PLACED_BUILDING_SCALE)
        .setAlpha(0.7)
        .setDepth(15) // Ensure it's on the topmost layer
        .setOrigin(0.5, 0.5); // Center the image
    console.log(`Drag preview created: ${dragPreview ? 'success' : 'failed'}`); // Confirm preview creation

    // 只有在预览创建成功后才设置拖动状态并添加监听器
    if (dragPreview) {
        isDraggingBuilding = true;
        draggedBuildingType = type;
        console.log(`Successfully started drag for: ${draggedBuildingType}`);
        // 添加全局监听器
        console.log('[DEBUG] Adding global pointermove/pointerup listeners.');
        gameScene.input.on('pointermove', handlePointerMove);
        gameScene.input.on('pointerup', handlePointerUp);
        console.log('[DEBUG] Listeners added.');
    } else {
        console.error("Failed to create drag preview, aborting drag start.");
        isDraggingBuilding = false; // Ensure flag is false if preview fails
        draggedBuildingType = null;
    }
}

// --- 全局拖放事件处理函数 ---
function handlePointerMove(pointer) {
    if (isDraggingBuilding && dragPreview) {
        console.log('[DEBUG] handlePointerMove: Dragging is active, updating preview.'); // Log inside the active drag
        const worldPoint = gameScene.cameras.main.getWorldPoint(pointer.x, pointer.y);
        dragPreview.setPosition(worldPoint.x, worldPoint.y);
        // 可以在这里重新加入放置有效性检查和透明度变化
        const snappedX = Math.floor(worldPoint.x / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2;
        const snappedY = Math.floor(worldPoint.y / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2;
        const canPlace = checkPlacementValidity(snappedX, snappedY);
        dragPreview.setAlpha(canPlace ? 0.7 : 0.4); // Dim if invalid
    } else if (isMovingBuilding && movingBuildingObject) {
        // --- Handle moving existing building --- 
        // console.log('[DEBUG] handlePointerMove: Moving is active, updating object position.');
        const worldPoint = gameScene.cameras.main.getWorldPoint(pointer.x, pointer.y);
        movingBuildingObject.setPosition(worldPoint.x, worldPoint.y);
        
        // Check validity for move
        const snappedX = Math.floor(worldPoint.x / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2;
        const snappedY = Math.floor(worldPoint.y / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2;
        const canPlace = checkPlacementValidity(snappedX, snappedY);
        movingBuildingObject.setAlpha(canPlace ? 0.7 : 0.4); // Dim if invalid move destination

    } else if (isDraggingBuilding) {
        console.warn('[DEBUG] handlePointerMove: isDraggingBuilding is true, but dragPreview is missing!');
    } else if (isMovingBuilding) {
        console.warn('[DEBUG] handlePointerMove: isMovingBuilding is true, but movingBuildingObject is missing!');
    }
}

function handlePointerUp(pointer) {
    // Handle drag-from-menu completion
    if (isDraggingBuilding && draggedBuildingType && dragPreview) {
        console.log(`[DEBUG] handlePointerUp triggered. Initial state: isDragging=${isDraggingBuilding}, type=${draggedBuildingType}, preview=${dragPreview ? 'exists' : 'null'}`);
        const worldPoint = gameScene.cameras.main.getWorldPoint(pointer.x, pointer.y);
        const placedX = Math.floor(worldPoint.x / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2;
        const placedY = Math.floor(worldPoint.y / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2;
        // const menuAreaY = gameScene.cameras.main.height - 70; // Old check
        // const menuAreaX = 150; // Old X boundary
        // Calculate menu boundary based on the background panel properties (add a buffer)
        const menuPanelBgX = 5; // Must match value in create()
        const menuPanelWidth = 180; // Must match value in create()
        const menuDropAreaX = menuPanelBgX + menuPanelWidth + 5; // Right edge of panel + buffer

        console.log(`[DEBUG] handlePointerUp: Processing drop at screen (${pointer.x}, ${pointer.y}), world (${worldPoint.x}, ${worldPoint.y}), snapped (${placedX}, ${placedY})`);

        // Check if pointer is over the menu area (using screen coordinates)
        if (pointer.x <= menuDropAreaX) { // Check if X is within the left menu panel area
            console.log("[DEBUG] handlePointerUp: Dropped in menu area (screen X <= menuDropAreaX), cancelling drag.");
            cancelPlacement(); // Will call stopDraggingBuilding internally
        } else {
            console.log(`[DEBUG] handlePointerUp: Dropped in game area. Attempting to place ${draggedBuildingType} at (${placedX}, ${placedY})`);
            tryPlaceBuilding(placedX, placedY, draggedBuildingType);
            console.log('[DEBUG] handlePointerUp: Calling stopDraggingBuilding after tryPlaceBuilding.');
            stopDraggingBuilding(); // Always stop after trying to place
        }
    }
    // Handle moving-existing-building completion
    else if (isMovingBuilding && movingBuildingObject) {
        console.log(`[DEBUG] handlePointerUp: Processing drop for moved building.`);
        const worldPoint = gameScene.cameras.main.getWorldPoint(pointer.x, pointer.y);
        const placedX = Math.floor(worldPoint.x / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2;
        const placedY = Math.floor(worldPoint.y / GRID_SIZE) * GRID_SIZE + GRID_SIZE / 2;

        // Check if dropped over UI area (e.g., menu) - use screen coordinates
        const menuPanelRect = document.getElementById('building-menu')?.getBoundingClientRect();
        const statsPanelRect = document.getElementById('stats-panel')?.getBoundingClientRect();
        let droppedInUI = false;
        if (menuPanelRect && pointer.x >= menuPanelRect.left && pointer.x <= menuPanelRect.right && pointer.y >= menuPanelRect.top && pointer.y <= menuPanelRect.bottom) droppedInUI = true;
        if (statsPanelRect && pointer.x >= statsPanelRect.left && pointer.x <= statsPanelRect.right && pointer.y >= statsPanelRect.top && pointer.y <= statsPanelRect.bottom) droppedInUI = true;
        // Add checks for other UI panels if necessary

        if (pointer.rightButtonReleased()) {
            // Cancel move on right click release
            console.log('[DEBUG] handlePointerUp: Right button released during move, cancelling.');
            cancelMovingBuilding();
        } else if (droppedInUI) {
            // Cancel move if dropped on UI
            console.log('[DEBUG] handlePointerUp: Dropped moved building in UI area, cancelling.');
            cancelMovingBuilding();
        } else {
            // Attempt to place in game area
            console.log(`[DEBUG] handlePointerUp: Attempting to place moved building at (${placedX}, ${placedY})`);
            if (checkPlacementValidity(placedX, placedY)) {
                // Place the building
                const type = movingBuildingObject.getData('type');
                const data = buildingData[type];
                movingBuildingObject.setPosition(placedX, placedY);
                movingBuildingObject.setAlpha(1.0).setDepth(1);

                // Add back to placedBuildings array
                placedBuildings.push({ type: type, x: placedX, y: placedY, phaserObject: movingBuildingObject });
                console.log(`[DEBUG] Placed moved ${type} at (${placedX}, ${placedY})`);

                // Re-apply effects
                currentPollution += data.pollution;
                currentHappiness += data.happiness;
                currentPopulation += data.population;
                currentPollution = Math.max(0, currentPollution);
                currentHappiness = Math.max(0, Math.min(100, currentHappiness));
                console.log(`[DEBUG] Re-applied effects for placed moved ${type}`);
                updateStats();

                // Update building effects (like parks, schools) if needed
                updateBuildingEffects();

                // Clean up state
                stopMovingBuilding();
            } else {
                // Invalid placement location, cancel move
                console.log('[DEBUG] handlePointerUp: Invalid placement for moved building, cancelling.');
                cancelMovingBuilding();
            }
        }
    } 
    // Handle inconsistent states or clicks not related to drag/move
    else if (isDraggingBuilding) {
        console.warn(`[DEBUG] handlePointerUp: Pointerup while isDraggingBuilding=true, but state inconsistent. Forcing stop drag.`);
        stopDraggingBuilding();
    } else if (isMovingBuilding) {
        console.warn(`[DEBUG] handlePointerUp: Pointerup while isMovingBuilding=true, but state inconsistent. Forcing stop move.`);
        stopMovingBuilding(); // Use stopMovingBuilding for cleanup
    } else {
        console.log('[DEBUG] handlePointerUp: Pointerup occurred, but not currently dragging or moving.');
    }
}

// 停止拖动建筑 (由 pointerup 或 cancelPlacement 调用)
function stopDraggingBuilding() {
    console.log(`[DEBUG] stopDraggingBuilding called. Current state: isDragging=${isDraggingBuilding}, type=${draggedBuildingType}, preview=${dragPreview ? 'exists' : 'null'}`);
    if (!isDraggingBuilding) { // Prevent redundant calls
        console.log('[DEBUG] stopDraggingBuilding: Already not dragging. Returning.');
        // Ensure listeners are definitely off if state is inconsistent
        if (gameScene && gameScene.input) {
             console.log('[DEBUG] stopDraggingBuilding: Removing listeners just in case (state was inconsistent).');
             gameScene.input.off('pointermove', handlePointerMove);
             gameScene.input.off('pointerup', handlePointerUp);
        }
        return;
    }

    // Store state before changing
    const wasDragging = isDraggingBuilding;
    const typeBeforeStop = draggedBuildingType;

    isDraggingBuilding = false;
    draggedBuildingType = null;

    if (dragPreview) {
        dragPreview.destroy();
        dragPreview = null;
        console.log("Drag preview destroyed.");
    } else {
        console.log("No drag preview to destroy.");
    }
    console.log("Dragging stopped.");
    // 移除全局监听器
    console.log('[DEBUG] Removing global pointermove/pointerup listeners.');
    gameScene.input.off('pointermove', handlePointerMove);
    gameScene.input.off('pointerup', handlePointerUp);
    console.log('[DEBUG] Listeners removed.');
}



// 取消放置/拖动 (例如按ESC 或 拖放到菜单)
function cancelPlacement() {
    console.log("Cancel placement called."); // Log cancel call
    if (isDraggingBuilding) {
        stopDraggingBuilding();
    }
    // 保留旧的 cancelPlacementMode 以防万一，但主要用 stopDraggingBuilding
    isPlacingBuilding = false; // 也重置旧的标志
    selectedBuildingType = null;
    if (placementPreview) { // 清理旧的预览（如果存在）
        placementPreview.destroy();
        placementPreview = null;
    }
    console.log("Placement/Dragging cancelled.");
}

function checkPlacementValidity(x, y) {
    // 检查是否在菜单区域
    // 注意：需要将屏幕坐标转换为世界坐标来比较，或者直接比较世界坐标
    // 简化：假设菜单区域固定在世界坐标的某个Y值以下 (需要根据相机调整)
    // const menuWorldY = gameScene.cameras.main.height - 50; // 粗略估计
    // if (y >= menuWorldY) return false;
    // 更可靠的方式是检查是否点击在菜单项上，但这在移动时检查比较复杂
    // 暂时只检查是否与其他建筑重叠

    const existingBuilding = placedBuildings.find(b => b.x === x && b.y === y);
    return !existingBuilding;
}

function tryPlaceBuilding(placedX, placedY, type) { // 接收建筑类型作为参数
    if (!type || !buildingData[type]) {
        console.error("Invalid building type for placement.");
        return;
    }
    const data = buildingData[type];

    // --- 新增：检查数量上限 ---
    if (data.maxCount !== null) {
        const currentCount = placedBuildings.filter(b => b.type === type).length;
        if (currentCount >= data.maxCount) {
            console.log(`Cannot place ${type}, maximum count (${data.maxCount}) reached.`);
            // 可选：向用户显示提示信息
            alert(`Cannot build more ${data.displayName || type}, maximum count (${data.maxCount}) reached!`);
            return; // 阻止放置
        }
    }
    // --- 结束：检查数量上限 ---

    // 检查是否可放置 (重叠检查)
    if (!checkPlacementValidity(placedX, placedY)) {
        console.log("Cannot place building here (overlaps or invalid area).");
        // Do not call stopDraggingBuilding here, let the pointerup handler do it
        return; // Placement failed
    }

    // 检查资金
    if (currentMoney < data.cost) {
        console.log("Not enough money.");
        alert("Not enough money!"); // Add user alert
        return; // Placement failed
    }

    // If enough money, proceed with placement (original logic was inverted)
    if (currentMoney >= data.cost) {
        currentMoney -= data.cost;
        currentPollution += data.pollution;
        currentHappiness += data.happiness;
        currentPopulation += data.population;

        // 限制满意度在 0-100`  
        currentHappiness = Math.max(0, Math.min(100, currentHappiness));
        // 限制污染不为负数
        currentPollution = Math.max(0, currentPollution);

        console.log(`Placed ${type}: Money=${currentMoney}, Pollution=${currentPollution}, Happiness=${currentHappiness}, Population=${currentPopulation}`);

        // Create building instance on the map
        const placedBuilding = gameScene.add.image(placedX, placedY, data.imageKey).setScale(PLACED_BUILDING_SCALE).setOrigin(0.5, 0.5);
        placedBuilding.setData('type', type);
        placedBuilding.setDepth(1);

        // Add to placed buildings array (Removed phaserObject duplication, simplified)
        // placedBuildings.push({ x: placedX, y: placedY, type: type, phaserObject: placedBuilding });

        // 如果是工厂，启动其收入计时器 (如果全局计时器未运行)
        if (type === 'factory' && !factoryIncomeTimer) {
            startFactoryIncome(gameScene);
        }

        updateStats();

        // 添加右键拆除功能
        placedBuilding.setInteractive();
        placedBuilding.on('pointerdown', function (pointer) {
            if (isDraggingBuilding || isMovingBuilding) return; // Ignore clicks if already dragging/moving
            
            if (pointer.leftButtonDown()) {
                // --- Start moving the building --- 
                startMovingBuilding(this, pointer); 
            } else if (pointer.rightButtonDown()) {
                // --- Remove the building --- 
                removeBuilding(this, placedX, placedY);
            }
        });

        // 存储已放置的建筑信息 (Removed nameText and bonusHappiness)
        placedBuildings.push({ type: type, x: placedX, y: placedY, phaserObject: placedBuilding });

        // 更新效果 (例如公园范围)
        updateBuildingEffects();

        // 如果是工厂，启动或更新income计时器
        if (type === 'factory') {
            startFactoryIncome(gameScene); // 确保计时器运行
        }

        updateStats();
        // 放置成功，拖动已在 pointerup 中停止
        // cancelPlacementMode(); // 不再需要在这里调用

        // 如果是污水处理厂，启动或确保污染减少计时器运行
        if (type === 'wastewater') {
            startPollutionReduction(gameScene); // 确保计时器运行
        }

    } else {
        console.log("资金不足！");
        // 资金不足，拖动已在 pointerup 中停止
        // cancelPlacementMode(); // 不再需要在这里调用
        // 可选：显示提示信息给玩家
    }
}

// --- 结束：放置模式辅助函数 ---

// 拆除建筑
function removeBuilding(buildingObject, x, y) { // Removed nameTextObject parameter
    const index = placedBuildings.findIndex(b => b.x === x && b.y === y);
    if (index !== -1) {
        const building = placedBuildings[index];
        const data = buildingData[building.type];

        // 回收50%成本
        currentMoney += Math.floor(data.cost * 0.5);
        // 移除建筑效果
        currentPollution -= data.pollution;
        currentHappiness -= data.happiness;
        currentPopulation -= data.population;

        // 限制满意度在 0-100
        currentHappiness = Math.max(0, Math.min(100, currentHappiness));
        // 限制污染不为负数
        currentPollution = Math.max(0, currentPollution);

        console.log(`Removed ${building.type} at (${x}, ${y}). Money +${Math.floor(data.cost * 0.5)}`);

        // 从数组和场景中移除
        placedBuildings.splice(index, 1);
        buildingObject.destroy();

        // 更新效果 (例如公园范围)
        updateBuildingEffects();

        // 如果拆除的是最后一个工厂，停止工厂计时器
        if (building.type === 'factory' && placedBuildings.filter(b => b.type === 'factory').length === 0) {
            if (factoryIncomeTimer) {
                factoryIncomeTimer.remove();
                factoryIncomeTimer = null;
                console.log("工厂收入计时器已停止");
            }
        }

        // 如果拆除的是最后一个污水处理厂，停止污染减少计时器 (新增)
        if (building.type === 'wastewater' && placedBuildings.filter(b => b.type === 'wastewater').length === 0) {
            if (pollutionReductionTimer) {
                pollutionReductionTimer.remove();
                pollutionReductionTimer = null;
                console.log("污水处理计时器已停止");
            }
        }

        updateStats();
    } else {
        console.error(`Building not found in placedBuildings at (${x}, ${y})`);
    }
}


// 更新UI数据
function updateStats() {
    const moneyEl = document.getElementById('money');
    const pollutionEl = document.getElementById('pollution');
    const happinessEl = document.getElementById('happiness');
    const populationEl = document.getElementById('population');

    console.log('[DEBUG] updateStats called. currentHappiness =', currentHappiness); // 添加日志

    if (moneyEl) moneyEl.textContent = currentMoney;
    if (pollutionEl) pollutionEl.textContent = currentPollution;
    if (happinessEl) happinessEl.textContent = currentHappiness;
    if (populationEl) populationEl.textContent = currentPopulation;
}

// 游戏循环（检测胜利/失败）
function update(time, delta) {
    // 失败条件
    if (currentMoney <= 0) {
        alert("Bankrupt! Game Over!");
        resetGame(this);
        return; // 避免继续检查胜利条件
    }
    if (currentPollution >= 100) {
        alert("Pollution too high! Mass exodus! Game Over!");
        currentPopulation = 0; // 人口归零
        resetGame(this);
        return; // 避免继续检查胜利条件
    }

    // 胜利条件
    if (currentPollution === 0 && currentMoney >= 5000 && placedBuildings.length > 0) { // 添加检查确保游戏已开始
        alert("Congratulations! [Zero Carbon City] goal achieved! Victory!");
        this.scene.pause(); // 暂停游戏
        // 可以在这里添加胜利动画或界面
    }
    if (currentHappiness >= 80 && currentPopulation >= 100000) { // 10万人口
        alert("Congratulations! [Population Boom] goal achieved! Victory!");
        this.scene.pause(); // 暂停游戏
    }
    if (currentMoney >= 30000) {
        alert("Congratulations! [Economic Powerhouse] goal achieved! Victory!");
        this.scene.pause(); // 暂停游戏
    }

    // TODO: 实现动态事件
    // TODO: 实现缩放与平移
    // TODO: 实现公园/医院等范围效果
}

// 重置游戏状态
function resetGame(scene) {
    currentMoney = 10000;
    currentPollution = 0;
    currentHappiness = 0;
    currentPopulation = 0;

    // 清除地图上的所有建筑
    placedBuildings.forEach(b => {
        if (b.phaserObject && typeof b.phaserObject.destroy === 'function') {
            b.phaserObject.destroy();
        }
    });
    placedBuildings = [];

    // 停止工厂计时器
    if (factoryIncomeTimer) {
        factoryIncomeTimer.remove();
        factoryIncomeTimer = null;
    }

    // 停止事件计时器
    if (eventTimer) {
        eventTimer.remove();
        eventTimer = null;
    }

    updateStats();
    console.log("游戏已重置");
    // 重新启动场景以完全重置
    scene.scene.restart();
}

// 启动工厂收入计时器
function startFactoryIncome(scene) {
    // 只有在计时器不存在或已停止时才创建新的
    if (!factoryIncomeTimer || factoryIncomeTimer.paused) {
        if (factoryIncomeTimer) factoryIncomeTimer.remove(); // 清理旧的

        // 确保 factory 数据存在
        if (!buildingData.factory) {
            console.error("Factory data not found in buildingData!");
            return;
        }

        factoryIncomeTimer = scene.time.addEvent({
            delay: buildingData.factory.incomeInterval, // 使用 buildingData 中的间隔
            callback: () => {
                const factoryCount = placedBuildings.filter(b => b.type === 'factory').length;
                if (factoryCount > 0) {
                    currentMoney += factoryCount * buildingData.factory.income;
                    console.log(`工厂收入: +${factoryCount * buildingData.factory.income}, 当前资金: ${currentMoney}`);
                    updateStats();
                }
            },
            loop: true
        });
        console.log("工厂收入计时器已启动");
    }
}

// 触发自然灾害
function triggerDisaster(scene) {
    const disasterType = Math.random() < 0.5 ? 'earthquake' : 'flood';
    if (disasterType === 'earthquake' && placedBuildings.length > 0) {
        const buildingIndexToRemove = Math.floor(Math.random() * placedBuildings.length);
        const buildingToRemove = placedBuildings[buildingIndexToRemove]; // Get the target building object
        
        // --- Fire Station Check --- 
        let isSavedByFireStation = false;
        const fireStations = placedBuildings.filter(b => b.type === 'fire');
        fireStations.forEach(fs => {
            const fsData = buildingData.fire;
            if (!fsData || !fsData.effectRadius) return;
            const distance = Phaser.Math.Distance.Between(fs.x, fs.y, buildingToRemove.x, buildingToRemove.y);
            if (distance <= fsData.effectRadius) {
                // 50% chance to save the building if within range
                if (Math.random() < 0.5) { 
                    isSavedByFireStation = true;
                    console.log(`Building at (${buildingToRemove.x}, ${buildingToRemove.y}) SAVED from earthquake by Fire Station at (${fs.x}, ${fs.y})!`);
                    alert(`Earthquake Warning! A ${buildingData[buildingToRemove.type].displayName || buildingToRemove.type} was threatened, but a nearby Fire Station prevented its destruction!`);
                }
            }
        });
        // --- End Fire Station Check ---

        // Only destroy if not saved
        if (!isSavedByFireStation) {
            alert(`Natural Disaster: Earthquake! A ${buildingData[buildingToRemove.type].displayName || buildingToRemove.type} at (${buildingToRemove.x}, ${buildingToRemove.y}) was destroyed!`);
            console.log(`Earthquake destroyed ${buildingToRemove.type} at (${buildingToRemove.x}, ${buildingToRemove.y})`);
            
            const buildingObject = buildingToRemove.phaserObject;
            // const index = placedBuildings.findIndex(b => b.phaserObject === buildingObject); // Already have index
            const index = buildingIndexToRemove;
            if (index !== -1) {
                const building = buildingToRemove; // Use the object we already have
                const data = buildingData[building.type];
                // ... remove effects ...
                placedBuildings.splice(index, 1);
                if (buildingObject && typeof buildingObject.destroy === 'function') {
                     buildingObject.destroy();
                }
                // ... check timers ...
                updateStats();
            }
        }

    } else if (disasterType === 'flood') {
        currentPollution += 10;
        currentPollution = Math.max(0, currentPollution); // 确保不为负
        alert("Natural Disaster: Flood! Pollution increased by 10!");
        console.log("Flood occurred, pollution +10");
        updateStats();
    }
}

// 检查并触发居民抗议
function checkProtestEvent() {
    if (currentHappiness <= 30 && placedBuildings.length > 0) {
        let baseProtestChance = 0.0005; // Base chance per frame
        let effectiveProtestChance = baseProtestChance;

        // --- Police Station Check --- 
        // Check if ANY police station covers the rough center of the map (simplified check)
        // A more complex check could see if police stations cover residential areas
        let isProtectedByPolice = false;
        const policeStations = placedBuildings.filter(b => b.type === 'police');
        // For simplicity, let's assume police presence anywhere reduces overall risk
        // A better implementation might check proximity to houses.
        if (policeStations.length > 0) { 
             // Reduce protest chance significantly if police are present (e.g., 80% reduction)
             effectiveProtestChance = baseProtestChance * 0.2; 
             isProtectedByPolice = true;
             // console.log(`Police presence detected, reducing protest chance to ${effectiveProtestChance}`);
        }
        // --- End Police Station Check --- 

        // 随机概率检查
        if (Math.random() < effectiveProtestChance) {
             const buildingIndexToDestroy = Math.floor(Math.random() * placedBuildings.length);
             const buildingToDestroy = placedBuildings[buildingIndexToDestroy];
             
             let alertMsg = `Citizen Protest! Due to low happiness`;
             if (isProtectedByPolice) alertMsg += ` (despite police presence!)`;
             alertMsg += `, a ${buildingData[buildingToDestroy.type].displayName || buildingToDestroy.type} at (${buildingToDestroy.x}, ${buildingToDestroy.y}) was destroyed!`;
             alert(alertMsg);
             console.log(`Protest destroyed ${buildingToDestroy.type} at (${buildingToDestroy.x}, ${buildingToDestroy.y})`);
             
             const buildingObject = buildingToDestroy.phaserObject;
             const index = buildingIndexToDestroy;
             if (index !== -1) {
                // ... remove effects ...
                placedBuildings.splice(index, 1);
                if (buildingObject && typeof buildingObject.destroy === 'function') {
                    buildingObject.destroy();
                }
                // ... check timers ...
                updateStats();
             }
        }
    }
}

// 触发经济危机
function triggerCrisis(scene) {
    const factoryCount = placedBuildings.filter(b => b.type === 'factory').length;
    if (factoryCount > 0 && factoryIncomeTimer && !factoryIncomeTimer.paused) {
        alert("Economic Crisis: Factory strike! Income generation paused for 10 seconds!");
        console.log("Economic Crisis: Factory strike for 10 seconds.");
        factoryIncomeTimer.paused = true;
        scene.time.delayedCall(10000, () => {
            if (factoryIncomeTimer) { // 检查计时器是否仍然存在
                 factoryIncomeTimer.paused = false;
                 console.log("Factory strike ended.");
                 alert("Factory strike ended. Production resumed.");
            }
        });
    }
}

// 启动动态事件计时器
function startEventTimer(scene) {
    if (eventTimer) eventTimer.remove(); // 清理旧的

    eventTimer = scene.time.addEvent({
        delay: 15000, // 每15秒尝试触发一次随机事件
        callback: () => {
            // 计算医院效果：每座医院降低负面事件概率 (例如，基础概率降低10%，最多降低50%)
            const hospitalCount = placedBuildings.filter(b => b.type === 'hospital').length;
            const reductionFactor = Math.min(0.5, hospitalCount * 0.1); // 每座医院降低10%，上限50%
            const effectiveEventChance = 0.3 * (1 - reductionFactor); // 基础总负面事件概率30%

            const randomChance = Math.random();
            console.log(`Event check: chance = ${randomChance.toFixed(3)}, threshold = ${effectiveEventChance.toFixed(3)} (Reduction: ${reductionFactor * 100}%)`);

            if (randomChance < effectiveEventChance) {
                // 在有效概率内，再随机选择灾害或危机
                if (Math.random() < 0.5) { // 50% 概率触发自然灾害
                    triggerDisaster(scene);
                } else { // 50% 概率触发经济危机
                    triggerCrisis(scene);
                }
            }
            // 居民抗议根据满意度在 update 中检查，不受医院影响
        },
        loop: true
    });
    console.log("Dynamic event timer started");
}

// Function to initialize the game
function startGame() {
    console.log('startGame function called'); // 添加日志
    // const game = new Phaser.Game(config); // Removed redundant game initialization
}

// Note: window.onload is removed, game will be started from index.html

// Ensure the DOM is fully loaded before adding event listeners to HTML elements
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM fully loaded, attaching event listeners.');

    // --- Game Rules Button Listener ---
    const rulesButton = document.getElementById('ai-button');
    const suggestionTextElement = document.getElementById('suggestion-text');

    if (rulesButton && suggestionTextElement) {
        rulesButton.addEventListener('click', () => {
            console.log('Game Rules button clicked. Displaying summary.');
            // Directly display the summary in the suggestion text area
            suggestionTextElement.innerHTML = ruleSummary;
        });
        console.log('Game Rules button event listener attached.');
    } else {
        if (!rulesButton) console.error("Game Rules button (#ai-button) not found after DOM loaded!");
        if (!suggestionTextElement) console.error("Suggestion text element (#suggestion-text) not found after DOM loaded!");
    }

    // --- HTML Menu Creation ---
    createHtmlMenu();

    // --- (Optional) AI Question Input Listener (Example) ---
    // const sendAiButton = document.getElementById('send-ai-question');
    // const aiInput = document.getElementById('ai-question-input');
    // if (sendAiButton && aiInput) {
    //     sendAiButton.addEventListener('click', () => {
    //         const question = aiInput.value;
    //         if (question.trim()) {
    //             console.log(`Sending question to AI: ${question}`);
    //             // Replace with your actual AI interaction logic
    //             // e.g., sendQuestionToAI(question); 
    //             aiInput.value = ''; // Clear input
    //         }
    //     });
    // }

});

// --- Function to Create HTML Building Menu ---
function createHtmlMenu() {
    console.log('Attempting to create HTML menu...');
    const menuContainer = document.getElementById('building-menu');
    if (!menuContainer) {
        console.error('HTML building menu container not found!');
        return;
    }
    menuContainer.innerHTML = ''; // Clear previous items if any

    Object.keys(buildingData).forEach(type => {
        const data = buildingData[type];
        if (!data.imageKey || !data.displayName) {
             console.warn(`Skipping HTML menu item for ${type} due to missing imageKey or displayName.`);
             return; 
        }

        const menuItem = document.createElement('div');
        menuItem.classList.add('menu-item');
        menuItem.dataset.buildingType = type; // Store type for the listener

        const img = document.createElement('img');
        img.src = `src/assets/pixel/${data.imageKey}.png`;
        img.alt = data.displayName;
        img.draggable = false; // 禁止原生拖拽
        img.addEventListener('dragstart', e => e.preventDefault()); // 阻止原生拖拽

        // Create a container for text details (name and cost)
        const textContainer = document.createElement('div');
        textContainer.classList.add('menu-item-details'); // Add a class for styling

        const nameSpan = document.createElement('span');
        // Handle multi-word names for wrapping if necessary (Wastewater example)
        if (type === 'wastewater') {
             nameSpan.innerHTML = 'Waste<br>water'; // Keep existing special case
        } else if (type === 'fire') {
             nameSpan.innerHTML = 'Fire<br>Station';
        } else if (type === 'police') {
             nameSpan.innerHTML = 'Police<br>Station';
        } else if (type === 'power') {
             nameSpan.innerHTML = 'Power<br>Plant';
        } else if (type === 'science') {
             nameSpan.innerHTML = 'Science<br>Lab';
        } else if (type === 'train') {
             nameSpan.innerHTML = 'Train<br>Station';
        } else if (type === 'waste') {
             nameSpan.innerHTML = 'Waste<br>Dump';
        } else if (type === 'watersupply') {
             nameSpan.innerHTML = 'Water<br>Supply';
        }
         else {
            nameSpan.textContent = data.displayName;
        }
        textContainer.appendChild(nameSpan);

        // Create and add the cost span
        const costSpan = document.createElement('span');
        costSpan.classList.add('menu-item-cost'); // Use existing class
        costSpan.textContent = `$${data.cost}`; // Display cost with a dollar sign
        textContainer.appendChild(costSpan);

        menuItem.appendChild(img); // Add image first
        menuItem.appendChild(textContainer); // Add text container below image

        // Add event listener to start Phaser drag
        menuItem.addEventListener('pointerdown', (event) => {
            event.preventDefault(); // 阻止原生拖拽
            const buildingType = event.currentTarget.dataset.buildingType;
            console.log(`HTML Menu item clicked: ${buildingType}`);
            if (gameScene && typeof startDraggingBuilding === 'function') {
                startDraggingBuilding(buildingType, event.clientX, event.clientY);
            } else {
                console.error('Game scene or startDraggingBuilding function not ready!');
            }
        });

        menuContainer.appendChild(menuItem);
    });
    console.log('HTML menu created.');
}

// 更新所有建筑的效果（例如公园对住宅的满意度加成）
function updateBuildingEffects() {
    // 重置所有建筑的临时效果加成
    // Ensure bonusHappiness exists on all relevant buildings (houses)
    placedBuildings.forEach(b => {
        if (b.type === 'house') {
            b.bonusHappiness = 0;
        } else {
            // Remove bonusHappiness from non-house buildings if it somehow got added
            delete b.bonusHappiness;
        }
    });

    // --- Calculate Happiness Bonuses --- 
    const houses = placedBuildings.filter(b => b.type === 'house');
    const schools = placedBuildings.filter(b => b.type === 'school');
    const libraries = placedBuildings.filter(b => b.type === 'library');

    // School bonus
    schools.forEach(school => {
        const schoolData = buildingData.school;
        if (!schoolData || !schoolData.effectRadius || schoolData.happiness <= 0) return;
        houses.forEach(house => {
            const distance = Phaser.Math.Distance.Between(school.x, school.y, house.x, house.y);
            if (distance <= schoolData.effectRadius) {
                house.bonusHappiness = (house.bonusHappiness || 0) + schoolData.happiness; // Add school's base happiness as bonus
                // console.log(`School at (${school.x}, ${school.y}) boosts happiness by ${schoolData.happiness} for house at (${house.x}, ${house.y})`);
            }
        });
    });

    // Library bonus
    libraries.forEach(library => {
        const libraryData = buildingData.library;
        if (!libraryData || !libraryData.effectRadius || libraryData.happiness <= 0) return;
        houses.forEach(house => {
            const distance = Phaser.Math.Distance.Between(library.x, library.y, house.x, house.y);
            if (distance <= libraryData.effectRadius) {
                house.bonusHappiness = (house.bonusHappiness || 0) + libraryData.happiness; // Add library's base happiness as bonus
                // console.log(`Library at (${library.x}, ${library.y}) boosts happiness by ${libraryData.happiness} for house at (${house.x}, ${house.y})`);
            }
        });
    });

    // --- Recalculate Total Happiness --- 
    let baseHappiness = 0;
    let totalBonusHappiness = 0;

    // Calculate base happiness from all buildings' direct effect
    placedBuildings.forEach(b => {
        const data = buildingData[b.type];
        if(data && data.happiness) baseHappiness += data.happiness;
    });

    // Calculate total bonus happiness applied to houses
    houses.forEach(house => {
        totalBonusHappiness += (house.bonusHappiness || 0);
    });
    
    // Final happiness is base effect + sum of bonuses on houses
    // Note: This calculation might double-count the base happiness of schools/libraries if they apply to themselves?
    // Simplified: Base happiness from ALL buildings + bonus happiness ONLY applied to houses. 
    // Recalculate base happiness EXCLUDING the bonus-providing buildings to avoid double counting.
    baseHappiness = 0; // Reset for recalculation
    placedBuildings.forEach(b => {
        const data = buildingData[b.type];
        // Exclude buildings that provide area bonuses from base calculation if their bonus is derived from base happiness
        if(data && data.happiness && b.type !== 'school' && b.type !== 'library') { 
            baseHappiness += data.happiness;
        }
    });
    // Add base happiness of bonus providers once
    schools.forEach(s => baseHappiness += (buildingData.school.happiness || 0));
    libraries.forEach(l => baseHappiness += (buildingData.library.happiness || 0));

    // Total = Base + Sum of Bonuses applied to houses
    currentHappiness = baseHappiness + totalBonusHappiness;
    
    // 限制满意度在 0-100
    currentHappiness = Math.max(0, Math.min(100, currentHappiness));

    console.log(`Recalculated Happiness: ${currentHappiness} (Base: ${baseHappiness}, Bonus: ${totalBonusHappiness})`);
    updateStats(); // 更新UI显示
}

// Make game instance accessible globally for AI interaction
let gameInstance;

// Removed duplicate config declaration. The main config is at the top of the file.

// Function to provide game state to other modules (like AI)
function getGameState() {
    return {
        money: currentMoney,
        pollution: currentPollution,
        happiness: currentHappiness,
        population: currentPopulation,
        buildings: placedBuildings.map(b => ({ // Return simplified data for AI
            type: b.type,
            x: b.x,
            y: b.y
            // Potentially add more relevant state if needed by AI
        }))
    };
}

// Expose necessary game functions/state globally for AI interaction
window.getGameState = getGameState;
console.log('game.js: window.getGameState assigned:', typeof window.getGameState); // Add log

// Expose necessary game functions globally - Removed placeBuildingByType as it's incomplete
window.game = {
    // Add functions needed by AI here, e.g.:
    // placeBuildingAt: (type, gridX, gridY) => { ... }
};

// 启动污水处理厂的周期性污染减少计时器
function startPollutionReduction(scene) {
    // 只有在计时器不存在或已停止时才创建新的
    if (!pollutionReductionTimer || pollutionReductionTimer.paused) {
        if (pollutionReductionTimer) pollutionReductionTimer.remove(); // 清理旧的

        const plantData = buildingData.wastewater;
        if (!plantData) {
            console.error("Wastewater data not found in buildingData!");
            return;
        }

        pollutionReductionTimer = scene.time.addEvent({
            delay: plantData.pollutionInterval, // 使用 buildingData 中的间隔 (e.g., 6000ms)
            callback: () => {
                const plantCount = placedBuildings.filter(b => b.type === 'wastewater').length;
                if (plantCount > 0) {
                    const reductionAmount = plantCount * plantData.pollutionReduction; // e.g., plantCount * 4
                    const oldPollution = currentPollution;
                    currentPollution -= reductionAmount;
                    currentPollution = Math.max(0, currentPollution); //确保不为负数
                    console.log(`污水处理厂效果: 污染 -${reductionAmount} (从 ${oldPollution} 降至 ${currentPollution})`);
                    updateStats();
                }
            },
            loop: true
        });
        console.log("污水处理计时器已启动");
    } else {
        console.log("污水处理计时器已在运行中");
    }
}

// --- NEW: Function to start moving an existing building ---
function startMovingBuilding(buildingPhaserObject, pointer) {
    if (isDraggingBuilding || isMovingBuilding) return; // Prevent starting move if already dragging/moving

    console.log('[DEBUG] Attempting to start moving building.');

    // Find the building data in the array
    const index = placedBuildings.findIndex(b => b.phaserObject === buildingPhaserObject);
    if (index === -1) {
        console.error('[DEBUG] Could not find building in placedBuildings to move.');
        return;
    }
    const buildingDataEntry = placedBuildings[index];
    const buildingType = buildingDataEntry.type;
    const data = buildingData[buildingType];

    // Store original position
    originalMovePos.x = buildingDataEntry.x;
    originalMovePos.y = buildingDataEntry.y;
    console.log(`[DEBUG] Stored original pos: (${originalMovePos.x}, ${originalMovePos.y})`);

    // Set state
    isMovingBuilding = true;
    movingBuildingObject = buildingPhaserObject;
    movingBuildingObject.setAlpha(0.7).setDepth(15); // Make it slightly transparent and bring to front

    // Temporarily remove building effects from global state
    currentPollution -= data.pollution;
    currentHappiness -= data.happiness;
    currentPopulation -= data.population;
    currentPollution = Math.max(0, currentPollution);
    currentHappiness = Math.max(0, Math.min(100, currentHappiness));
    console.log(`[DEBUG] Reversed effects for moving ${buildingType}`);
    updateStats();

    // Remove from placedBuildings array temporarily
    placedBuildings.splice(index, 1);
    console.log(`[DEBUG] Temporarily removed ${buildingType} from placedBuildings.`);

    // Add global listeners for moving
    console.log('[DEBUG] Adding global pointermove/pointerup listeners for MOVE.');
    gameScene.input.on('pointermove', handlePointerMove); // Reuse existing handlers
    gameScene.input.on('pointerup', handlePointerUp);
}

// --- NEW: Function to stop the moving process (after placing or cancelling) ---
function stopMovingBuilding() {
    console.log('[DEBUG] stopMovingBuilding called.');
    if (!isMovingBuilding) return; // Prevent redundant calls

    if (movingBuildingObject) {
        movingBuildingObject.setAlpha(1.0).setDepth(1); // Restore alpha and depth
    }

    isMovingBuilding = false;
    movingBuildingObject = null;
    originalMovePos = { x: null, y: null };

    // Remove global listeners
    console.log('[DEBUG] Removing global pointermove/pointerup listeners for MOVE/DRAG.');
    gameScene.input.off('pointermove', handlePointerMove);
    gameScene.input.off('pointerup', handlePointerUp);
}

// --- NEW: Function to cancel the move and return building to original spot ---
function cancelMovingBuilding() {
    console.log('[DEBUG] cancelMovingBuilding called.');
    if (!isMovingBuilding || !movingBuildingObject || originalMovePos.x === null) {
        console.warn('[DEBUG] Cancel move called in invalid state.');
        stopMovingBuilding(); // Attempt cleanup anyway
        return;
    }

    const type = movingBuildingObject.getData('type');
    const data = buildingData[type];

    // Move sprite back
    movingBuildingObject.setPosition(originalMovePos.x, originalMovePos.y);
    console.log(`[DEBUG] Moved ${type} back to (${originalMovePos.x}, ${originalMovePos.y})`);

    // Add back to placedBuildings array at original position
    placedBuildings.push({ type: type, x: originalMovePos.x, y: originalMovePos.y, phaserObject: movingBuildingObject });
    console.log(`[DEBUG] Added ${type} back to placedBuildings at original position.`);

    // Re-apply effects
    currentPollution += data.pollution;
    currentHappiness += data.happiness;
    currentPopulation += data.population;
    currentPollution = Math.max(0, currentPollution);
    currentHappiness = Math.max(0, Math.min(100, currentHappiness));
    console.log(`[DEBUG] Re-applied effects for cancelled move of ${type}`);
    updateStats();

    // Update building effects (like parks, schools) if needed
    updateBuildingEffects();

    // Clean up state
    stopMovingBuilding();
}

const game = new Phaser.Game(config);